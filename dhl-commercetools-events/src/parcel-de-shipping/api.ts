/* tslint:disable */
/* eslint-disable */
/**
 * Parcel DE Shipping API (Post & Parcel Germany)
 * Note: This is the specification of the DPDHL Group Parcel DE Shipping API for Post & Parcel Germany. This REST web service allows business customers to create shipping labels on demand.
 *
 * The version of the OpenAPI document: 2.1.7
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 * Bank account data used for CoD (Cash on Delivery).
 * @export
 * @interface BankAccount
 */
export interface BankAccount {
  /**
   *
   * @type {string}
   * @memberof BankAccount
   */
  accountHolder: string;
  /**
   *
   * @type {string}
   * @memberof BankAccount
   */
  bankName?: string;
  /**
   *
   * @type {string}
   * @memberof BankAccount
   */
  iban: string;
  /**
   *
   * @type {string}
   * @memberof BankAccount
   */
  bic?: string;
}
/**
 * Commodity line item (e.g. a t-shirt) for international shipments which require individual listing of goods. Each good must contain a description of the item, the amount of the item, the net weight of one single item and the value of one single item. If you ship 5 t-shirts, you need to include the weight and value of one single shirt. The correct final weight and value will be calculated automatically. The HS Code and the country of origin are optional.
 * @export
 * @interface Commodity
 */
export interface Commodity {
  /**
   *
   * @type {string}
   * @memberof Commodity
   */
  itemDescription: string;
  /**
   *
   * @type {Country}
   * @memberof Commodity
   */
  countryOfOrigin?: Country;
  /**
   * Harmonized System Code aka Customs tariff number.
   * @type {string}
   * @memberof Commodity
   */
  hsCode?: string;
  /**
   * How many items of that type are in the package
   * @type {number}
   * @memberof Commodity
   */
  packagedQuantity: number;
  /**
   *
   * @type {Value}
   * @memberof Commodity
   */
  itemValue: Value;
  /**
   *
   * @type {Weight}
   * @memberof Commodity
   */
  itemWeight: Weight;
}

/**
 * @type Consignee
 * Consignee address information. Either a doorstep address (contact address) including contact information or a droppoint address. One of packstation (parcel locker), or post office (postfiliale/retail shop).
 * @export
 */
export type Consignee = ContactAddress | Locker | POBox | PostOffice;

/**
 * Combines name, address, contact information. The recommended way is to use the mandatory attribute addressStreet and submit the streetname and housenumber together â€“ alternatively addressHouse + addressStreet can be used. For many international addresses there is no house number, please do not set a period or any other sign to indicate that the address does not have a housenumber.
 * @export
 * @interface ContactAddress
 */
export interface ContactAddress {
  /**
   * Name1. Line 1 of name information
   * @type {string}
   * @memberof ContactAddress
   */
  name1: string;
  /**
   * An optional, additional line of name information
   * @type {string}
   * @memberof ContactAddress
   */
  name2?: string;
  /**
   * An optional, additional line of name information
   * @type {string}
   * @memberof ContactAddress
   */
  name3?: string;
  /**
   * An optional, additional line of address. It\'s only usable for a few countries, e.g. Belgium. It is positioned below name3 on the label.
   * @type {string}
   * @memberof ContactAddress
   */
  dispatchingInformation?: string;
  /**
   * Line 1 of the street address. This is just the street name. Can also include house number.
   * @type {string}
   * @memberof ContactAddress
   */
  addressStreet: string;
  /**
   * Line 1 of the street address. This is just the house number. Can be added to street name instead.
   * @type {string}
   * @memberof ContactAddress
   */
  addressHouse?: string;
  /**
   * Additional information that is positioned either behind or below addressStreet on the label. If it is printed and where exactly depends on the country.
   * @type {string}
   * @memberof ContactAddress
   */
  additionalAddressInformation1?: string;
  /**
   * Additional information that is positioned either behind or below addressStreet on the label. If it is printed and where exactly depends on the country.
   * @type {string}
   * @memberof ContactAddress
   */
  additionalAddressInformation2?: string;
  /**
   * Mandatory for all countries but Ireland that use a postal code system.
   * @type {string}
   * @memberof ContactAddress
   */
  postalCode?: string;
  /**
   * city
   * @type {string}
   * @memberof ContactAddress
   */
  city: string;
  /**
   * State, province or territory. For the USA please use the official regional ISO-Codes, e.g. US-AL.
   * @type {string}
   * @memberof ContactAddress
   */
  state?: string;
  /**
   *
   * @type {Country}
   * @memberof ContactAddress
   */
  country: Country;
  /**
   * optional contact name. (this is not the primary name printed on label)
   * @type {string}
   * @memberof ContactAddress
   */
  contactName?: string;
  /**
   * Please note that, in accordance with Art. 4 No. 11 GDPR, you must obtain the recipient\'s consent to forward their phone number to Deutsche Post DHL Group. For shipments within Germany, the phone number cannot be transmitted. In some countries the provision of a telephone number and/or e-mail address is mandatory for a delivery to a droppoint. If your recipient has objected to the disclosure of their telephone number and/or e-mail address, the shipment can only be delivered in these countries using the service Premium.
   * @type {string}
   * @memberof ContactAddress
   */
  phone?: string;
  /**
   * Please note that, in accordance with Art. 4 No. 11 GDPR, you must obtain the recipient\'s consent to forward their e-mail address to Deutsche Post DHL Group. For shipments within Germany, the e-mail address is used to send a DHL Parcel Notification to the recipient. The e-mail address is not mandatory for shipments within Germany. In some countries the provision of a telephone number and/or e-mail address is mandatory for a delivery to a droppoint. If your recipient has objected to the disclosure of their telephone number and/or e-mail address, the shipment can only be delivered in these countries using the service Premium.
   * @type {string}
   * @memberof ContactAddress
   */
  email?: string;
}

/**
 * A valid country code consisting of three characters according to ISO 3166-1 alpha-3.
 * @export
 * @enum {string}
 */

export const Country = {
  Abw: 'ABW',
  Afg: 'AFG',
  Ago: 'AGO',
  Aia: 'AIA',
  Ala: 'ALA',
  Alb: 'ALB',
  And: 'AND',
  Are: 'ARE',
  Arg: 'ARG',
  Arm: 'ARM',
  Asm: 'ASM',
  Atg: 'ATG',
  Aus: 'AUS',
  Aut: 'AUT',
  Aze: 'AZE',
  Bdi: 'BDI',
  Bel: 'BEL',
  Ben: 'BEN',
  Bes: 'BES',
  Bfa: 'BFA',
  Bgd: 'BGD',
  Bgr: 'BGR',
  Bhr: 'BHR',
  Bhs: 'BHS',
  Bih: 'BIH',
  Blm: 'BLM',
  Blr: 'BLR',
  Blz: 'BLZ',
  Bmu: 'BMU',
  Bol: 'BOL',
  Bra: 'BRA',
  Brb: 'BRB',
  Brn: 'BRN',
  Btn: 'BTN',
  Bvt: 'BVT',
  Bwa: 'BWA',
  Caf: 'CAF',
  Can: 'CAN',
  Cck: 'CCK',
  Che: 'CHE',
  Chl: 'CHL',
  Chn: 'CHN',
  Civ: 'CIV',
  Cmr: 'CMR',
  Cod: 'COD',
  Cog: 'COG',
  Cok: 'COK',
  Col: 'COL',
  Com: 'COM',
  Cpv: 'CPV',
  Cri: 'CRI',
  Cub: 'CUB',
  Cuw: 'CUW',
  Cxr: 'CXR',
  Cym: 'CYM',
  Cyp: 'CYP',
  Cze: 'CZE',
  Deu: 'DEU',
  Dji: 'DJI',
  Dma: 'DMA',
  Dnk: 'DNK',
  Dom: 'DOM',
  Dza: 'DZA',
  Ecu: 'ECU',
  Egy: 'EGY',
  Eri: 'ERI',
  Esp: 'ESP',
  Est: 'EST',
  Eth: 'ETH',
  Fin: 'FIN',
  Fji: 'FJI',
  Flk: 'FLK',
  Fra: 'FRA',
  Fro: 'FRO',
  Fsm: 'FSM',
  Gab: 'GAB',
  Gbr: 'GBR',
  Geo: 'GEO',
  Ggy: 'GGY',
  Gha: 'GHA',
  Gib: 'GIB',
  Gin: 'GIN',
  Glp: 'GLP',
  Gmb: 'GMB',
  Gnb: 'GNB',
  Gnq: 'GNQ',
  Grc: 'GRC',
  Grd: 'GRD',
  Grl: 'GRL',
  Gtm: 'GTM',
  Guf: 'GUF',
  Gum: 'GUM',
  Guy: 'GUY',
  Hkg: 'HKG',
  Hmd: 'HMD',
  Hnd: 'HND',
  Hrv: 'HRV',
  Hti: 'HTI',
  Hun: 'HUN',
  Idn: 'IDN',
  Imn: 'IMN',
  Ind: 'IND',
  Irl: 'IRL',
  Irn: 'IRN',
  Irq: 'IRQ',
  Isl: 'ISL',
  Isr: 'ISR',
  Ita: 'ITA',
  Jam: 'JAM',
  Jey: 'JEY',
  Jor: 'JOR',
  Jpn: 'JPN',
  Kaz: 'KAZ',
  Ken: 'KEN',
  Kgz: 'KGZ',
  Khm: 'KHM',
  Kir: 'KIR',
  Kna: 'KNA',
  Kor: 'KOR',
  Kwt: 'KWT',
  Lao: 'LAO',
  Lbn: 'LBN',
  Lbr: 'LBR',
  Lby: 'LBY',
  Lca: 'LCA',
  Lie: 'LIE',
  Lka: 'LKA',
  Lso: 'LSO',
  Ltu: 'LTU',
  Lux: 'LUX',
  Lva: 'LVA',
  Mac: 'MAC',
  Maf: 'MAF',
  Mar: 'MAR',
  Mco: 'MCO',
  Mda: 'MDA',
  Mdg: 'MDG',
  Mdv: 'MDV',
  Mex: 'MEX',
  Mhl: 'MHL',
  Mkd: 'MKD',
  Mli: 'MLI',
  Mlt: 'MLT',
  Mmr: 'MMR',
  Mne: 'MNE',
  Mng: 'MNG',
  Mnp: 'MNP',
  Moz: 'MOZ',
  Mrt: 'MRT',
  Msr: 'MSR',
  Mtq: 'MTQ',
  Mus: 'MUS',
  Mwi: 'MWI',
  Mys: 'MYS',
  Myt: 'MYT',
  Nam: 'NAM',
  Ncl: 'NCL',
  Ner: 'NER',
  Nfk: 'NFK',
  Nga: 'NGA',
  Nic: 'NIC',
  Niu: 'NIU',
  Nld: 'NLD',
  Nor: 'NOR',
  Npl: 'NPL',
  Nru: 'NRU',
  Nzl: 'NZL',
  Omn: 'OMN',
  Pak: 'PAK',
  Pan: 'PAN',
  Pcn: 'PCN',
  Per: 'PER',
  Phl: 'PHL',
  Plw: 'PLW',
  Png: 'PNG',
  Pol: 'POL',
  Pri: 'PRI',
  Prk: 'PRK',
  Prt: 'PRT',
  Pry: 'PRY',
  Pse: 'PSE',
  Pyf: 'PYF',
  Qat: 'QAT',
  Reu: 'REU',
  Rou: 'ROU',
  Rus: 'RUS',
  Rwa: 'RWA',
  Sau: 'SAU',
  Sdn: 'SDN',
  Sen: 'SEN',
  Sgp: 'SGP',
  Shn: 'SHN',
  Sjm: 'SJM',
  Slb: 'SLB',
  Sle: 'SLE',
  Slv: 'SLV',
  Smr: 'SMR',
  Som: 'SOM',
  Spm: 'SPM',
  Srb: 'SRB',
  Ssd: 'SSD',
  Stp: 'STP',
  Sur: 'SUR',
  Svk: 'SVK',
  Svn: 'SVN',
  Swe: 'SWE',
  Swz: 'SWZ',
  Sxm: 'SXM',
  Syc: 'SYC',
  Syr: 'SYR',
  Tca: 'TCA',
  Tcd: 'TCD',
  Tgo: 'TGO',
  Tha: 'THA',
  Tjk: 'TJK',
  Tkl: 'TKL',
  Tkm: 'TKM',
  Tls: 'TLS',
  Ton: 'TON',
  Tto: 'TTO',
  Tun: 'TUN',
  Tur: 'TUR',
  Tuv: 'TUV',
  Twn: 'TWN',
  Tza: 'TZA',
  Uga: 'UGA',
  Ukr: 'UKR',
  Ury: 'URY',
  Usa: 'USA',
  Uzb: 'UZB',
  Vat: 'VAT',
  Vct: 'VCT',
  Ven: 'VEN',
  Vgb: 'VGB',
  Vir: 'VIR',
  Vnm: 'VNM',
  Vut: 'VUT',
  Wlf: 'WLF',
  Wsm: 'WSM',
  Yem: 'YEM',
  Zaf: 'ZAF',
  Zmb: 'ZMB',
  Zwe: 'ZWE',
  Unknown: 'UNKNOWN',
} as const;

export type Country = (typeof Country)[keyof typeof Country];

/**
 * For international shipments, this section contains information necessary for customs about the exported goods. ExportDocument can contain one or more positions as child element. This data is also transferred as electronic declaration to customs. The custom details are mandatory depending on whether the parcel will go to a country outside the European Customs Union. For DHL Parcel International (V53WPAK) CN23 will returned as a separate document, while for Warenpost International the customs information will be printed onto the shipment label (CN22).
 * @export
 * @interface CustomsDetails
 */
export interface CustomsDetails {
  /**
   * Invoice number
   * @type {string}
   * @memberof CustomsDetails
   */
  invoiceNo?: string;
  /**
   * This contains the category of goods contained in parcel.
   * @type {string}
   * @memberof CustomsDetails
   */
  exportType: CustomsDetailsExportTypeEnum;
  /**
   * Mandatory if exporttype is \'OTHER\'
   * @type {string}
   * @memberof CustomsDetails
   */
  exportDescription?: string;
  /**
   * Aka \'Terms of Trade\' aka \'Frankatur\'. The attribute is exclusively used for the product Europaket (V54EPAK). DDU is deprecated (use DAP instead).
   * @type {string}
   * @memberof CustomsDetails
   */
  shippingConditions?: CustomsDetailsShippingConditionsEnum;
  /**
   * Permit number. Very rarely needed. Mostly relevant for higher value goods. An example use case would be an item made from crocodile leather which requires dedicated license / permit identified by that number.
   * @type {string}
   * @memberof CustomsDetails
   */
  permitNo?: string;
  /**
   * Attest or certification identified by this number. Very rarely needed. An example use case would be a medical shipment referring to an attestation that a certain amount of medicine may be imported within e.g. the current quarter of the year.
   * @type {string}
   * @memberof CustomsDetails
   */
  attestationNo?: string;
  /**
   * flag confirming whether electronic record for export was made
   * @type {boolean}
   * @memberof CustomsDetails
   */
  hasElectronicExportNotification?: boolean;
  /**
   *
   * @type {Value}
   * @memberof CustomsDetails
   */
  postalCharges?: Value;
  /**
   * Optional. Will appear on CN23.
   * @type {string}
   * @memberof CustomsDetails
   */
  officeOfOrigin?: string;
  /**
   * Optional. The customs reference is used by customs authorities to identify economics operators an/or other persons involved. With the given reference, granted authorizations and/or relevant processes in customs clearance an/or taxation can be taken into account. Aka Zoll-Nummer or EORI-Number but dependent on destination.
   * @type {string}
   * @memberof CustomsDetails
   */
  shipperCustomsRef?: string;
  /**
   * Optional. The customs reference is used by customs authorities to identify economics operators an/or other persons involved. With the given reference, granted authorizations and/or relevant processes in customs clearance an/or taxation can be taken into account. Aka Zoll-Nummer or EORI-Number but dependent on destination.
   * @type {string}
   * @memberof CustomsDetails
   */
  consigneeCustomsRef?: string;
  /**
   * Commodity types in that package
   * @type {Array<Commodity>}
   * @memberof CustomsDetails
   */
  items: Array<Commodity>;
}

export const CustomsDetailsExportTypeEnum = {
  Other: 'OTHER',
  Present: 'PRESENT',
  CommercialSample: 'COMMERCIAL_SAMPLE',
  Document: 'DOCUMENT',
  ReturnOfGoods: 'RETURN_OF_GOODS',
  CommercialGoods: 'COMMERCIAL_GOODS',
} as const;

export type CustomsDetailsExportTypeEnum =
  (typeof CustomsDetailsExportTypeEnum)[keyof typeof CustomsDetailsExportTypeEnum];
export const CustomsDetailsShippingConditionsEnum = {
  Ddu: 'DDU',
  Dap: 'DAP',
  Ddp: 'DDP',
  Ddx: 'DDX',
  Dxv: 'DXV',
} as const;

export type CustomsDetailsShippingConditionsEnum =
  (typeof CustomsDetailsShippingConditionsEnum)[keyof typeof CustomsDetailsShippingConditionsEnum];

/**
 * Physical dimensions (aka \'Gurtmass\') of the parcel. If you provide the dimension information, all attributes need to be provided. You cannot provide just the height, for example. If you provide length, width, and height in millimeters, they will be rounded to full cm.
 * @export
 * @interface Dimensions
 */
export interface Dimensions {
  /**
   * Unit of metric, applies to all dimensions contained.
   * @type {string}
   * @memberof Dimensions
   */
  uom: DimensionsUomEnum;
  /**
   *
   * @type {number}
   * @memberof Dimensions
   */
  height: number;
  /**
   *
   * @type {number}
   * @memberof Dimensions
   */
  length: number;
  /**
   *
   * @type {number}
   * @memberof Dimensions
   */
  width: number;
}

export const DimensionsUomEnum = {
  Cm: 'cm',
  Mm: 'mm',
} as const;

export type DimensionsUomEnum =
  (typeof DimensionsUomEnum)[keyof typeof DimensionsUomEnum];

/**
 * Encoded document. All types of labels and documents.
 * @export
 * @interface Document
 */
export interface Document {
  /**
   * The Base64 encoded byte stream
   * @type {string}
   * @memberof Document
   */
  b64?: string;
  /**
   * The document in zpl encoding
   * @type {string}
   * @memberof Document
   */
  zpl2?: string;
  /**
   * URL reference to download document
   * @type {string}
   * @memberof Document
   */
  url?: string;
  /**
   * format of the encoded bytes
   * @type {string}
   * @memberof Document
   */
  fileFormat?: DocumentFileFormatEnum;
  /**
   * The print format used
   * @type {string}
   * @memberof Document
   */
  printFormat?: DocumentPrintFormatEnum;
}

export const DocumentFileFormatEnum = {
  Zpl2: 'ZPL2',
  Pdf: 'PDF',
} as const;

export type DocumentFileFormatEnum =
  (typeof DocumentFileFormatEnum)[keyof typeof DocumentFileFormatEnum];
export const DocumentPrintFormatEnum = {
  A4Pt: 'A4-PT',
  A4: 'A4',
  _910300700: '910-300-700',
  _910300700OZOz: '910-300-700-oZ/oz',
  _910300300: '910-300-300',
  _910300300Oz: '910-300-300-oz',
  _910300710: '910-300-710',
  _910300600610: '910-300-600/610',
  _910300400410: '910-300-400/410',
  _100x70mm: '100x70mm',
} as const;

export type DocumentPrintFormatEnum =
  (typeof DocumentPrintFormatEnum)[keyof typeof DocumentPrintFormatEnum];

/**
 *
 * @export
 * @interface GetManifestData
 */
export interface GetManifestData {
  /**
   * The encoded byte stream
   * @type {Array<string>}
   * @memberof GetManifestData
   */
  b64?: Array<string>;
  /**
   * The document in zpl encoding
   * @type {string}
   * @memberof GetManifestData
   */
  zpl2?: string;
  /**
   * URL reference to download document
   * @type {string}
   * @memberof GetManifestData
   */
  url?: string;
  /**
   * format of the encoded bytes
   * @type {string}
   * @memberof GetManifestData
   */
  fileFormat?: GetManifestDataFileFormatEnum;
  /**
   * The print format used
   * @type {string}
   * @memberof GetManifestData
   */
  printFormat?: GetManifestDataPrintFormatEnum;
}

export const GetManifestDataFileFormatEnum = {
  Zpl2: 'ZPL2',
  Pdf: 'PDF',
} as const;

export type GetManifestDataFileFormatEnum =
  (typeof GetManifestDataFileFormatEnum)[keyof typeof GetManifestDataFileFormatEnum];
export const GetManifestDataPrintFormatEnum = {
  A4Pt: 'A4-PT',
  A4: 'A4',
  _910300700: '910-300-700',
  _910300700OZOz: '910-300-700-oZ/oz',
  _910300300: '910-300-300',
  _910300300Oz: '910-300-300-oz',
  _910300710: '910-300-710',
  _910300600610: '910-300-600/610',
  _910300400410: '910-300-400/410',
  _100x70mm: '100x70mm',
} as const;

export type GetManifestDataPrintFormatEnum =
  (typeof GetManifestDataPrintFormatEnum)[keyof typeof GetManifestDataPrintFormatEnum];

/**
 *
 * @export
 * @interface LabelDataResponse
 */
export interface LabelDataResponse {
  /**
   *
   * @type {RequestStatus}
   * @memberof LabelDataResponse
   */
  status?: RequestStatus;
  /**
   * For consistency, response is a single element array.
   * @type {Array<ResponseItem>}
   * @memberof LabelDataResponse
   */
  items?: Array<ResponseItem>;
}
/**
 * Only usable for German Packstation, international lockers cannot be addressed directly. If your customer wishes for international delivery to a droppoint, please use DHL Parcel International (V53WPAK) with the delivery type \"Closest Droppoint\".
 * @export
 * @interface Locker
 */
export interface Locker {
  /**
   * Name
   * @type {string}
   * @memberof Locker
   */
  name: string;
  /**
   * Packstationnummer. Three digit number identifying the parcel locker in conjunction with city and postal code
   * @type {number}
   * @memberof Locker
   */
  lockerID: number;
  /**
   * postNumber (Postnummer) is the official account number a private DHL Customer gets upon registration.
   * @type {string}
   * @memberof Locker
   */
  postNumber: string;
  /**
   * City where the locker is located
   * @type {string}
   * @memberof Locker
   */
  city: string;
  /**
   *
   * @type {Country}
   * @memberof Locker
   */
  country?: Country;
  /**
   *
   * @type {string}
   * @memberof Locker
   */
  postalCode: string;
}

/**
 * Response of the POST /manifests endpoint containing an overall request status and detailed shipment status.
 * @export
 * @interface MultipleManifestResponse
 */
export interface MultipleManifestResponse {
  /**
   *
   * @type {RequestStatus}
   * @memberof MultipleManifestResponse
   */
  status?: RequestStatus;
  /**
   *
   * @type {Array<ShortResponseItem>}
   * @memberof MultipleManifestResponse
   */
  items?: Array<ShortResponseItem>;
}
/**
 * Alternative destination - P.O. Box (Postfach)
 * @export
 * @interface POBox
 */
export interface POBox {
  /**
   * Name1. Line 1 of name information
   * @type {string}
   * @memberof POBox
   */
  name1: string;
  /**
   * An optional, additional line of name information
   * @type {string}
   * @memberof POBox
   */
  name2?: string;
  /**
   * An optional, additional line of name information
   * @type {string}
   * @memberof POBox
   */
  name3?: string;
  /**
   * Number of P.O. Box (Postfach)
   * @type {number}
   * @memberof POBox
   */
  poBoxID: number;
  /**
   * Email address of the consignee
   * @type {string}
   * @memberof POBox
   */
  email?: string;
  /**
   * City of the P.O. Box (Postfach) location
   * @type {string}
   * @memberof POBox
   */
  city: string;
  /**
   *
   * @type {Country}
   * @memberof POBox
   */
  country?: Country;
  /**
   * Postal code of the P.O. Box (Postfach) location
   * @type {string}
   * @memberof POBox
   */
  postalCode: string;
}

/**
 * Only usable for German post offices or retail outlets (Paketshops), international postOffices or retail outlets cannot be addressed directly. If your customer wishes for international delivery to a droppoint, please use DHL Parcel International (V53WPAK) with the delivery type \"Closest Droppoint\".
 * @export
 * @interface PostOffice
 */
export interface PostOffice {
  /**
   * Name
   * @type {string}
   * @memberof PostOffice
   */
  name: string;
  /**
   * Id or Number of Post office / Filiale / outlet / parcel shop
   * @type {number}
   * @memberof PostOffice
   */
  retailID: number;
  /**
   * postNumber (Postnummer) is the official account number a private DHL Customer gets upon registration. To address a post office or retail outlet directly, either the post number or e-mail address of the consignee is needed.
   * @type {string}
   * @memberof PostOffice
   */
  postNumber?: string;
  /**
   * Email address of the consignee. To address a post office or retail outlet directly, either the post number or e-mail address of the consignee is needed.
   * @type {string}
   * @memberof PostOffice
   */
  email?: string;
  /**
   * City where the retail location is
   * @type {string}
   * @memberof PostOffice
   */
  city: string;
  /**
   *
   * @type {Country}
   * @memberof PostOffice
   */
  country?: Country;
  /**
   *
   * @type {string}
   * @memberof PostOffice
   */
  postalCode: string;
}

/**
 * General status description for the attached response or response item.
 * @export
 * @interface RequestStatus
 */
export interface RequestStatus {
  /**
   *
   * @type {string}
   * @memberof RequestStatus
   */
  title: string;
  /**
   * The status code of the response. Usually, but not necessarliy the HTTP status code.
   * @type {number}
   * @memberof RequestStatus
   */
  statusCode: number;
  /**
   * A URI reference that identifies the specific occurrence of the problem.
   * @type {string}
   * @memberof RequestStatus
   */
  instance?: string;
  /**
   *
   * @type {string}
   * @memberof RequestStatus
   */
  detail?: string;
}
/**
 * Response for a single shipment containing status, numbers and labels
 * @export
 * @interface ResponseItem
 */
export interface ResponseItem {
  /**
   *
   * @type {string}
   * @memberof ResponseItem
   */
  shipmentNo?: string;
  /**
   *
   * @type {string}
   * @memberof ResponseItem
   */
  returnShipmentNo?: string;
  /**
   *
   * @type {RequestStatus}
   * @memberof ResponseItem
   */
  sstatus: RequestStatus;
  /**
   *
   * @type {string}
   * @memberof ResponseItem
   */
  shipmentRefNo?: string;
  /**
   *
   * @type {Document}
   * @memberof ResponseItem
   */
  label?: Document;
  /**
   *
   * @type {Document}
   * @memberof ResponseItem
   */
  returnLabel?: Document;
  /**
   *
   * @type {Document}
   * @memberof ResponseItem
   */
  customsDoc?: Document;
  /**
   *
   * @type {Document}
   * @memberof ResponseItem
   */
  codLabel?: Document;
  /**
   * Optional validation messages attached to the shipment.
   * @type {Array<ValidationMessageItem>}
   * @memberof ResponseItem
   */
  validationMessages?: Array<ValidationMessageItem>;
}
/**
 * Response for the API version endpoint detailing version information.
 * @export
 * @interface ServiceInformation
 */
export interface ServiceInformation {
  /**
   *
   * @type {ServiceInformationAmp}
   * @memberof ServiceInformation
   */
  amp?: ServiceInformationAmp;
  /**
   *
   * @type {ServiceInformationBackend}
   * @memberof ServiceInformation
   */
  backend?: ServiceInformationBackend;
}
/**
 *
 * @export
 * @interface ServiceInformationAmp
 */
export interface ServiceInformationAmp {
  /**
   * name of api
   * @type {string}
   * @memberof ServiceInformationAmp
   */
  name?: string;
  /**
   * environment
   * @type {string}
   * @memberof ServiceInformationAmp
   */
  env?: string;
  /**
   * version of api
   * @type {string}
   * @memberof ServiceInformationAmp
   */
  version?: string;
  /**
   * revision
   * @type {string}
   * @memberof ServiceInformationAmp
   */
  rev?: string;
}
/**
 *
 * @export
 * @interface ServiceInformationBackend
 */
export interface ServiceInformationBackend {
  /**
   * environment
   * @type {string}
   * @memberof ServiceInformationBackend
   */
  env?: string;
  /**
   * version of backend
   * @type {string}
   * @memberof ServiceInformationBackend
   */
  version?: string;
}
/**
 * Container for all shipments. Mixed shipment products per request are supported. Each shipment has a dedicated shipper address (or shipper reference, or both).
 * @export
 * @interface Shipment
 */
export interface Shipment {
  /**
   * Determines the DHL Paket product to be used.  * V01PAK: DHL PAKET; * V53WPAK: DHL PAKET International; * V54EPAK: DHL Europaket; * V62WP: Warenpost; * V66WPI: Warenpost International
   * @type {string}
   * @memberof Shipment
   */
  product?: string;
  /**
   * 14 digit long number that identifies the contract the shipment is booked on. Please note that in rare cases the last to characters can be letters. Digit 11 and digit 12 must correspondent to the number of the product, e.g. 333333333301tt can only be used for the product V01PAK (DHL Paket).
   * @type {string}
   * @memberof Shipment
   */
  billingNumber?: string;
  /**
   * A reference number that the user can assign for better association purposes. It appears on shipment labels. To use the reference number for tracking purposes, it should be at least 8 characters long and unique.
   * @type {string}
   * @memberof Shipment
   */
  refNo?: string;
  /**
   * Textfield that appears on the shipment label. It cannot be used to search for the shipment.
   * @type {string}
   * @memberof Shipment
   */
  costCenter?: string;
  /**
   * Is only to be indicated by DHL partners.
   * @type {string}
   * @memberof Shipment
   */
  creationSoftware?: string;
  /**
   * Date the shipment is transferred to DHL. The shipment date can be the current date or a date up to a few days in the future. It must not be in the past. Iso format required: yyyy-mm-dd. On the shipment date the shipment will be automatically closed at your end of day closing time.
   * @type {string}
   * @memberof Shipment
   */
  shipDate?: string;
  /**
   *
   * @type {ShipmentShipper}
   * @memberof Shipment
   */
  shipper?: ShipmentShipper;
  /**
   *
   * @type {Consignee}
   * @memberof Shipment
   */
  consignee?: Consignee;
  /**
   *
   * @type {ShipmentDetails}
   * @memberof Shipment
   */
  details?: ShipmentDetails;
  /**
   *
   * @type {VAS}
   * @memberof Shipment
   */
  services?: VAS;
  /**
   *
   * @type {CustomsDetails}
   * @memberof Shipment
   */
  customs?: CustomsDetails;
}
/**
 * Details for the shipment, such as dimensions, content
 * @export
 * @interface ShipmentDetails
 */
export interface ShipmentDetails {
  /**
   *
   * @type {Dimensions}
   * @memberof ShipmentDetails
   */
  dim?: Dimensions;
  /**
   *
   * @type {Weight}
   * @memberof ShipmentDetails
   */
  weight: Weight;
}
/**
 * List of shipments which shall be manifested.
 * @export
 * @interface ShipmentManifestingRequest
 */
export interface ShipmentManifestingRequest {
  /**
   *
   * @type {string}
   * @memberof ShipmentManifestingRequest
   */
  profile: string;
  /**
   * List of shipment IDs for manifesting.
   * @type {Array<string>}
   * @memberof ShipmentManifestingRequest
   */
  shipmentNumbers?: Array<string>;
  /**
   * Customer billingNumber number.
   * @type {string}
   * @memberof ShipmentManifestingRequest
   */
  billingNumber?: string;
}
/**
 * Complex request structure used to create, update, and validate shipment data. Note that most elements are part of the array of shipment items.
 * @export
 * @interface ShipmentOrderRequest
 */
export interface ShipmentOrderRequest {
  /**
   *
   * @type {string}
   * @memberof ShipmentOrderRequest
   */
  profile: string;
  /**
   * Shipment array having details for each shipment.
   * @type {Array<Shipment>}
   * @memberof ShipmentOrderRequest
   */
  shipments: Array<Shipment>;
}
/**
 * @type ShipmentShipper
 * Shipper information, including contact information and address. Alternatively, a predefined shipper reference can be used.
 * @export
 */
export type ShipmentShipper = Shipper | ShipperReference;

/**
 * Shipper information, including contact information and address.
 * @export
 * @interface Shipper
 */
export interface Shipper {
  /**
   * Name1. Line 1 of name information
   * @type {string}
   * @memberof Shipper
   */
  name1: string;
  /**
   * An optional, additional line of name information
   * @type {string}
   * @memberof Shipper
   */
  name2?: string;
  /**
   * An optional, additional line of name information
   * @type {string}
   * @memberof Shipper
   */
  name3?: string;
  /**
   * Line 1 of the street address. This is just the street name. Can also include house number.
   * @type {string}
   * @memberof Shipper
   */
  addressStreet: string;
  /**
   * Line 1 of the street address. This is just the house number. Can be added to street name instead.
   * @type {string}
   * @memberof Shipper
   */
  addressHouse?: string;
  /**
   * Mandatory for all countries but Ireland that use a postal code system.
   * @type {string}
   * @memberof Shipper
   */
  postalCode?: string;
  /**
   * city
   * @type {string}
   * @memberof Shipper
   */
  city: string;
  /**
   *
   * @type {Country}
   * @memberof Shipper
   */
  country: Country;
  /**
   * optional contact name. (this is not the primary name printed on label)
   * @type {string}
   * @memberof Shipper
   */
  contactName?: string;
  /**
   * Optional contact email address of the shipper
   * @type {string}
   * @memberof Shipper
   */
  email?: string;
}

/**
 * Contains a reference to the Shipper data configured in GKP(GeschÃ¤ftskundenportal - Business Costumer Portal). Can be used instead of a detailed shipper address. The shipper reference can be used to print a company logo which is configured in GKP onto the label.
 * @export
 * @interface ShipperReference
 */
export interface ShipperReference {
  /**
   * Reference string to the shipper data configured in GKP(GeschÃ¤ftskundenportal - Business Costumer Portal).
   * @type {string}
   * @memberof ShipperReference
   */
  shipperRef: string;
}
/**
 * Response for a single shipment element not containing labels.
 * @export
 * @interface ShortResponseItem
 */
export interface ShortResponseItem {
  /**
   *
   * @type {string}
   * @memberof ShortResponseItem
   */
  shipmentNo?: string;
  /**
   *
   * @type {RequestStatus}
   * @memberof ShortResponseItem
   */
  sstatus: RequestStatus;
}
/**
 *
 * @export
 * @interface SingleManifestResponse
 */
export interface SingleManifestResponse {
  /**
   *
   * @type {RequestStatus}
   * @memberof SingleManifestResponse
   */
  status?: RequestStatus;
  /**
   *
   * @type {string}
   * @memberof SingleManifestResponse
   */
  manifestDate?: string;
  /**
   *
   * @type {GetManifestData}
   * @memberof SingleManifestResponse
   */
  manifest?: GetManifestData;
}
/**
 * Value added services. Please note that services are specific to products and geographies and/or may require individual setup and billing numbers. Please test and contact your account representative in case of questions.
 * @export
 * @interface VAS
 */
export interface VAS {
  /**
   * Preferred neighbour. Can be specified as text.
   * @type {string}
   * @memberof VAS
   */
  preferredNeighbour?: string;
  /**
   * Preferred location. Can be specified as text.
   * @type {string}
   * @memberof VAS
   */
  preferredLocation?: string;
  /**
   * if used it will trigger checking the age of recipient
   * @type {string}
   * @memberof VAS
   */
  visualCheckOfAge?: VASVisualCheckOfAgeEnum;
  /**
   * Delivery can only be signed for by yourself personally.
   * @type {boolean}
   * @memberof VAS
   */
  namedPersonOnly?: boolean;
  /**
   *
   * @type {VASIdentCheck}
   * @memberof VAS
   */
  identCheck?: VASIdentCheck;
  /**
   * Delivery must be signed for by the recipient and not by DHL staff
   * @type {boolean}
   * @memberof VAS
   */
  signedForByRecipient?: boolean;
  /**
   * Instructions and endorsement how to treat international undeliverable shipment. By default, shipments are returned if undeliverable. There are country specific rules whether the shipment is returned immediately or after a grace period.
   * @type {string}
   * @memberof VAS
   */
  endorsement?: VASEndorsementEnum;
  /**
   * Preferred day of delivery in format YYYY-MM-DD. Shipper can request a preferred day of delivery. The preferred day should be between 2 and 6 working days after handover to DHL.
   * @type {string}
   * @memberof VAS
   */
  preferredDay?: string;
  /**
   * Delivery can only be signed for by yourself personally or by members of your household.
   * @type {boolean}
   * @memberof VAS
   */
  noNeighbourDelivery?: boolean;
  /**
   *
   * @type {Value}
   * @memberof VAS
   */
  additionalInsurance?: Value;
  /**
   * Leaving this out is same as setting to false. Sperrgut.
   * @type {boolean}
   * @memberof VAS
   */
  bulkyGoods?: boolean;
  /**
   *
   * @type {VASCashOnDelivery}
   * @memberof VAS
   */
  cashOnDelivery?: VASCashOnDelivery;
  /**
   * Special instructions for delivery. 2 character code, possible values agreed in contract.
   * @type {string}
   * @memberof VAS
   */
  individualSenderRequirement?: string;
  /**
   * Choice of premium vs economy parcel. Availability is country dependent and may be manipulated by DHL if choice is not available. Please review the label.
   * @type {boolean}
   * @memberof VAS
   */
  premium?: boolean;
  /**
   * Closest Droppoint Delivery to the droppoint closest to the address of the recipient of the shipment. For this kind of delivery either the phone number and/or the e-mail address of the receiver is mandatory. For shipments using DHL Paket International it is recommended that you choose one of the three delivery types: Economy, Premium, CDP. Otherwise, the current default for the receiver country will be picked.
   * @type {boolean}
   * @memberof VAS
   */
  closestDropPoint?: boolean;
  /**
   * Undeliverable domestic shipment can be forwarded and held at retail. Notification to email (fallback: consignee email) will be used.
   * @type {string}
   * @memberof VAS
   */
  parcelOutletRouting?: string;
  /**
   *
   * @type {VASDhlRetoure}
   * @memberof VAS
   */
  dhlRetoure?: VASDhlRetoure;
  /**
   * All import duties are paid by the shipper.
   * @type {boolean}
   * @memberof VAS
   */
  postalDeliveryDutyPaid?: boolean;
}

export const VASVisualCheckOfAgeEnum = {
  A16: 'A16',
  A18: 'A18',
} as const;

export type VASVisualCheckOfAgeEnum =
  (typeof VASVisualCheckOfAgeEnum)[keyof typeof VASVisualCheckOfAgeEnum];
export const VASEndorsementEnum = {
  Return: 'RETURN',
  Abandon: 'ABANDON',
} as const;

export type VASEndorsementEnum =
  (typeof VASEndorsementEnum)[keyof typeof VASEndorsementEnum];

/**
 * Cash on delivery (Nachnahme). Currency must be Euro. Either bank account information or account reference (from customer profile) must be provided. Transfernote1 + 2 are references transmitted during bank transfer. Providing account information explicitly requires elevated privileges.
 * @export
 * @interface VASCashOnDelivery
 */
export interface VASCashOnDelivery {
  /**
   *
   * @type {Value}
   * @memberof VASCashOnDelivery
   */
  amount?: Value;
  /**
   *
   * @type {BankAccount}
   * @memberof VASCashOnDelivery
   */
  bankAccount?: BankAccount;
  /**
   * Reference to bank account details. Account references are maintained in customer settings in Post & DHL business customer portal under Ship -> Settings -> Cash on delivery. Please note, that the default account reference is used if the provided account reference does not exist in your customer settings!
   * @type {string}
   * @memberof VASCashOnDelivery
   */
  accountReference?: string;
  /**
   *
   * @type {string}
   * @memberof VASCashOnDelivery
   */
  transferNote1?: string;
  /**
   *
   * @type {string}
   * @memberof VASCashOnDelivery
   */
  transferNote2?: string;
}
/**
 * Requests return label (aka \'retoure\') to be provided. Also requires returnAddress and return billing number. Neither weight nor dimension need to be specified for the retoure (flat rate service).
 * @export
 * @interface VASDhlRetoure
 */
export interface VASDhlRetoure {
  /**
   *
   * @type {string}
   * @memberof VASDhlRetoure
   */
  billingNumber: string;
  /**
   *
   * @type {string}
   * @memberof VASDhlRetoure
   */
  refNo?: string;
  /**
   *
   * @type {ContactAddress}
   * @memberof VASDhlRetoure
   */
  returnAddress?: ContactAddress;
}
/**
 * Check the identity of the recipient via name (firstname, lastname), date of birth or age. This uses firstName and lastName as separate attributes since for identity check an automatic split of a one-line name is not considered reliable enough.
 * @export
 * @interface VASIdentCheck
 */
export interface VASIdentCheck {
  /**
   *
   * @type {string}
   * @memberof VASIdentCheck
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof VASIdentCheck
   */
  lastName: string;
  /**
   * date of birth, used in conjunction with minimumAge and shipping date. Format yyyy-mm-dd is used.
   * @type {string}
   * @memberof VASIdentCheck
   */
  dateOfBirth?: string;
  /**
   * Checks if recipient will have reached specified age by shipping date.
   * @type {string}
   * @memberof VASIdentCheck
   */
  minimumAge?: VASIdentCheckMinimumAgeEnum;
}

export const VASIdentCheckMinimumAgeEnum = {
  A16: 'A16',
  A18: 'A18',
} as const;

export type VASIdentCheckMinimumAgeEnum =
  (typeof VASIdentCheckMinimumAgeEnum)[keyof typeof VASIdentCheckMinimumAgeEnum];

/**
 * Representation of a validation message of a shipment container containing the most important information.
 * @export
 * @interface ValidationMessageItem
 */
export interface ValidationMessageItem {
  /**
   * The property that is affected by the validation message.
   * @type {string}
   * @memberof ValidationMessageItem
   */
  property?: string;
  /**
   * The validation message describing the error.
   * @type {string}
   * @memberof ValidationMessageItem
   */
  validationMessage?: string;
  /**
   * The validation state resulting from the error.
   * @type {string}
   * @memberof ValidationMessageItem
   */
  validationState?: string;
}
/**
 * Currency and numeric value.
 * @export
 * @interface Value
 */
export interface Value {
  /**
   * iso 4217 3 character currency code accepted. Recommended to use EUR where possible
   * @type {string}
   * @memberof Value
   */
  currency: ValueCurrencyEnum;
  /**
   * Numeric value
   * @type {number}
   * @memberof Value
   */
  value: number;
}

export const ValueCurrencyEnum = {
  Aed: 'AED',
  Afn: 'AFN',
  All: 'ALL',
  Amd: 'AMD',
  Ang: 'ANG',
  Aoa: 'AOA',
  Ars: 'ARS',
  Aud: 'AUD',
  Awg: 'AWG',
  Azn: 'AZN',
  Bam: 'BAM',
  Bbd: 'BBD',
  Bdt: 'BDT',
  Bgn: 'BGN',
  Bhd: 'BHD',
  Bif: 'BIF',
  Bmd: 'BMD',
  Bnd: 'BND',
  Bob: 'BOB',
  Bov: 'BOV',
  Brl: 'BRL',
  Bsd: 'BSD',
  Btn: 'BTN',
  Bwp: 'BWP',
  Byr: 'BYR',
  Bzd: 'BZD',
  Cad: 'CAD',
  Cdf: 'CDF',
  Che: 'CHE',
  Chf: 'CHF',
  Chw: 'CHW',
  Clf: 'CLF',
  Clp: 'CLP',
  Cny: 'CNY',
  Cop: 'COP',
  Cou: 'COU',
  Crc: 'CRC',
  Cuc: 'CUC',
  Cup: 'CUP',
  Cve: 'CVE',
  Czk: 'CZK',
  Djf: 'DJF',
  Dkk: 'DKK',
  Dop: 'DOP',
  Dzd: 'DZD',
  Egp: 'EGP',
  Ern: 'ERN',
  Etb: 'ETB',
  Eur: 'EUR',
  Fjd: 'FJD',
  Fkp: 'FKP',
  Gbp: 'GBP',
  Gel: 'GEL',
  Ghs: 'GHS',
  Gip: 'GIP',
  Gmd: 'GMD',
  Gnf: 'GNF',
  Gtq: 'GTQ',
  Gyd: 'GYD',
  Hkd: 'HKD',
  Hnl: 'HNL',
  Hrk: 'HRK',
  Htg: 'HTG',
  Huf: 'HUF',
  Idr: 'IDR',
  Ils: 'ILS',
  Inr: 'INR',
  Iqd: 'IQD',
  Irr: 'IRR',
  Isk: 'ISK',
  Jmd: 'JMD',
  Jod: 'JOD',
  Jpy: 'JPY',
  Kes: 'KES',
  Kgs: 'KGS',
  Khr: 'KHR',
  Kmf: 'KMF',
  Kpw: 'KPW',
  Krw: 'KRW',
  Kwd: 'KWD',
  Kyd: 'KYD',
  Kzt: 'KZT',
  Lak: 'LAK',
  Lbp: 'LBP',
  Lkr: 'LKR',
  Lrd: 'LRD',
  Lsl: 'LSL',
  Ltl: 'LTL',
  Lvl: 'LVL',
  Lyd: 'LYD',
  Mad: 'MAD',
  Mdl: 'MDL',
  Mga: 'MGA',
  Mkd: 'MKD',
  Mmk: 'MMK',
  Mnt: 'MNT',
  Mop: 'MOP',
  Mro: 'MRO',
  Mur: 'MUR',
  Mvr: 'MVR',
  Mwk: 'MWK',
  Mxn: 'MXN',
  Mxv: 'MXV',
  Myr: 'MYR',
  Mzn: 'MZN',
  Nad: 'NAD',
  Ngn: 'NGN',
  Nio: 'NIO',
  Nok: 'NOK',
  Npr: 'NPR',
  Nzd: 'NZD',
  Omr: 'OMR',
  Pab: 'PAB',
  Pen: 'PEN',
  Pgk: 'PGK',
  Php: 'PHP',
  Pkr: 'PKR',
  Pln: 'PLN',
  Pyg: 'PYG',
  Qar: 'QAR',
  Ron: 'RON',
  Rsd: 'RSD',
  Rub: 'RUB',
  Rwf: 'RWF',
  Sar: 'SAR',
  Sbd: 'SBD',
  Scr: 'SCR',
  Sdg: 'SDG',
  Sek: 'SEK',
  Sgd: 'SGD',
  Shp: 'SHP',
  Sll: 'SLL',
  Sos: 'SOS',
  Srd: 'SRD',
  Ssp: 'SSP',
  Std: 'STD',
  Syp: 'SYP',
  Szl: 'SZL',
  Thb: 'THB',
  Tjs: 'TJS',
  Tmt: 'TMT',
  Tnd: 'TND',
  Top: 'TOP',
  Try: 'TRY',
  Ttd: 'TTD',
  Twd: 'TWD',
  Tzs: 'TZS',
  Uah: 'UAH',
  Ugx: 'UGX',
  Usd: 'USD',
  Usn: 'USN',
  Uss: 'USS',
  Uyi: 'UYI',
  Uyu: 'UYU',
  Uzs: 'UZS',
  Vef: 'VEF',
  Vnd: 'VND',
  Vuv: 'VUV',
  Wst: 'WST',
  Xaf: 'XAF',
  Xag: 'XAG',
  Xau: 'XAU',
  Xba: 'XBA',
  Xbb: 'XBB',
  Xbc: 'XBC',
  Xbd: 'XBD',
  Xcd: 'XCD',
  Xdr: 'XDR',
  Xfu: 'XFU',
  Xof: 'XOF',
  Xpd: 'XPD',
  Xpf: 'XPF',
  Xpt: 'XPT',
  Xxx: 'XXX',
  Yer: 'YER',
  Zar: 'ZAR',
  Zmw: 'ZMW',
  Unknown: 'UNKNOWN',
} as const;

export type ValueCurrencyEnum =
  (typeof ValueCurrencyEnum)[keyof typeof ValueCurrencyEnum];

/**
 * Weight of item or shipment. Both uom and value are required.
 * @export
 * @interface Weight
 */
export interface Weight {
  /**
   * metric unit for weight
   * @type {string}
   * @memberof Weight
   */
  uom: WeightUomEnum;
  /**
   *
   * @type {number}
   * @memberof Weight
   */
  value: number;
}

export const WeightUomEnum = {
  G: 'g',
  Kg: 'kg',
} as const;

export type WeightUomEnum = (typeof WeightUomEnum)[keyof typeof WeightUomEnum];

/**
 * GeneralApi - axios parameter creator
 * @export
 */
export const GeneralApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns the current version of the API as major.minor.patch. Furthermore, it will also return more details (semantic version number, revision, environment) of the API layer.
     * @summary Return API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootGet: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GeneralApi - functional programming interface
 * @export
 */
export const GeneralApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GeneralApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the current version of the API as major.minor.patch. Furthermore, it will also return more details (semantic version number, revision, environment) of the API layer.
     * @summary Return API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rootGet(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ServiceInformation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.rootGet(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['GeneralApi.rootGet']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * GeneralApi - factory interface
 * @export
 */
export const GeneralApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = GeneralApiFp(configuration);
  return {
    /**
     * Returns the current version of the API as major.minor.patch. Furthermore, it will also return more details (semantic version number, revision, environment) of the API layer.
     * @summary Return API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootGet(options?: any): AxiosPromise<ServiceInformation> {
      return localVarFp
        .rootGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GeneralApi - object-oriented interface
 * @export
 * @class GeneralApi
 * @extends {BaseAPI}
 */
export class GeneralApi extends BaseAPI {
  /**
   * Returns the current version of the API as major.minor.patch. Furthermore, it will also return more details (semantic version number, revision, environment) of the API layer.
   * @summary Return API version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneralApi
   */
  public rootGet(options?: RawAxiosRequestConfig) {
    return GeneralApiFp(this.configuration)
      .rootGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ManifestsApi - axios parameter creator
 * @export
 */
export const ManifestsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Return the manifest document for the specific date (abbreviated ISO8601 format YYYY-MM-DD). If no date is provided, the manifest for today will be returned. The manifest PDF document will list the shipments for your EKP, separated by billing numbers. Potentially, the document is large and response time will reflect this. <br />Additionally, the response contains a mapping of billing numbers to sheet numbers of the manifest and a mapping of shipment numbers to sheet numbers.<br />The call can be repeated as often as needed. Should a date be provided which is too old or lies within the future, HTTP 400 is returned.
     * @summary Retrieve daily manifest document
     * @param {string} [billingNumber] Customer billingNumber number.
     * @param {string} [date]
     * @param {GetManifestsIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.  Default is include the base64 encoded labels.
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManifests: async (
      billingNumber?: string,
      date?: string,
      includeDocs?: GetManifestsIncludeDocsEnum,
      acceptLanguage?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/manifests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'dhl-api-key',
        configuration
      );

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (billingNumber !== undefined) {
        localVarQueryParameter['billingNumber'] = billingNumber;
      }

      if (date !== undefined) {
        localVarQueryParameter['date'] = date;
      }

      if (includeDocs !== undefined) {
        localVarQueryParameter['includeDocs'] = includeDocs;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Shipments are normally \'\'closed out\'\' at a fixed time of the day (such as 6 pm, configured by EKP/account) for the date provided as shipDate in the create call.  <br />This call allows forcing the closeout for sets of shipments earlier. This will also override the original shipDate. Afterwards, the shipment cannot be changed and the shipment labels cannot be queried anymore (however they may remain cached for limited duration).  Calling closeout repeatedly for the same shipments will result in HTTP 400 for the second call. HTTP 400 will also be returned if the automatic closeout happened prior to the call. It is however possible to add new shipments, they will be manifested as well and be part of the day\'s manifest.  <br />Note on billing: The manifesting step has billing implications. Some products (Warenpost, Parcel International partially) are billed based on the shipment data available to DHL at the end of the day. All other products (including DHL Paket Standard) are billed based on production data. For more details, please contact your account representative.   #### Request It\'s changing the status of the shipment, so parameters are provided in the body.  * \'\'profile\'\' attribute - defines the user group profile. A user group is permitted to specific billing numbers. Shipments are only closed out if they belong to a billing number that the user group profile is entitled to use. This attribute is mandatory. Please use the standard user group profile \'\'STANDARD_GRUPPENPROFIL\'\' if no dedicated user group profile is available.  * \'\'billingNumber\'\' attribute - defines the billing number for which shipments shall be closed out. If a billing number is set, then only the shipments of that billing number are closed out. In that case no list of specific shipment numbers needs to be passed.  * \'\'shipmentNumbers\'\' attribute - lists the specific shipping numbers of the shipments that shall be closed out.  If all shipments shall be closed, the query parameter \'\'all\'\' needs to be set to \'\'true\'\'. In that case neither a billing number nor a list of shipment numbers need to be passed in the request body.   #### Response  * Closing status for each shipment
     * @summary Mark shipments as being ready for shipping
     * @param {ShipmentManifestingRequest} shipmentManifestingRequest
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {boolean} [all] Specify if all applicable shipments shall be marked as being ready for shipping.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    manifestsPost: async (
      shipmentManifestingRequest: ShipmentManifestingRequest,
      acceptLanguage?: string,
      all?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipmentManifestingRequest' is not null or undefined
      assertParamExists(
        'manifestsPost',
        'shipmentManifestingRequest',
        shipmentManifestingRequest
      );
      const localVarPath = `/manifests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'dhl-api-key',
        configuration
      );

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        shipmentManifestingRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ManifestsApi - functional programming interface
 * @export
 */
export const ManifestsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ManifestsApiAxiosParamCreator(configuration);
  return {
    /**
     * Return the manifest document for the specific date (abbreviated ISO8601 format YYYY-MM-DD). If no date is provided, the manifest for today will be returned. The manifest PDF document will list the shipments for your EKP, separated by billing numbers. Potentially, the document is large and response time will reflect this. <br />Additionally, the response contains a mapping of billing numbers to sheet numbers of the manifest and a mapping of shipment numbers to sheet numbers.<br />The call can be repeated as often as needed. Should a date be provided which is too old or lies within the future, HTTP 400 is returned.
     * @summary Retrieve daily manifest document
     * @param {string} [billingNumber] Customer billingNumber number.
     * @param {string} [date]
     * @param {GetManifestsIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.  Default is include the base64 encoded labels.
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getManifests(
      billingNumber?: string,
      date?: string,
      includeDocs?: GetManifestsIncludeDocsEnum,
      acceptLanguage?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SingleManifestResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getManifests(
        billingNumber,
        date,
        includeDocs,
        acceptLanguage,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ManifestsApi.getManifests']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Shipments are normally \'\'closed out\'\' at a fixed time of the day (such as 6 pm, configured by EKP/account) for the date provided as shipDate in the create call.  <br />This call allows forcing the closeout for sets of shipments earlier. This will also override the original shipDate. Afterwards, the shipment cannot be changed and the shipment labels cannot be queried anymore (however they may remain cached for limited duration).  Calling closeout repeatedly for the same shipments will result in HTTP 400 for the second call. HTTP 400 will also be returned if the automatic closeout happened prior to the call. It is however possible to add new shipments, they will be manifested as well and be part of the day\'s manifest.  <br />Note on billing: The manifesting step has billing implications. Some products (Warenpost, Parcel International partially) are billed based on the shipment data available to DHL at the end of the day. All other products (including DHL Paket Standard) are billed based on production data. For more details, please contact your account representative.   #### Request It\'s changing the status of the shipment, so parameters are provided in the body.  * \'\'profile\'\' attribute - defines the user group profile. A user group is permitted to specific billing numbers. Shipments are only closed out if they belong to a billing number that the user group profile is entitled to use. This attribute is mandatory. Please use the standard user group profile \'\'STANDARD_GRUPPENPROFIL\'\' if no dedicated user group profile is available.  * \'\'billingNumber\'\' attribute - defines the billing number for which shipments shall be closed out. If a billing number is set, then only the shipments of that billing number are closed out. In that case no list of specific shipment numbers needs to be passed.  * \'\'shipmentNumbers\'\' attribute - lists the specific shipping numbers of the shipments that shall be closed out.  If all shipments shall be closed, the query parameter \'\'all\'\' needs to be set to \'\'true\'\'. In that case neither a billing number nor a list of shipment numbers need to be passed in the request body.   #### Response  * Closing status for each shipment
     * @summary Mark shipments as being ready for shipping
     * @param {ShipmentManifestingRequest} shipmentManifestingRequest
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {boolean} [all] Specify if all applicable shipments shall be marked as being ready for shipping.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async manifestsPost(
      shipmentManifestingRequest: ShipmentManifestingRequest,
      acceptLanguage?: string,
      all?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MultipleManifestResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.manifestsPost(
        shipmentManifestingRequest,
        acceptLanguage,
        all,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ManifestsApi.manifestsPost']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ManifestsApi - factory interface
 * @export
 */
export const ManifestsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ManifestsApiFp(configuration);
  return {
    /**
     * Return the manifest document for the specific date (abbreviated ISO8601 format YYYY-MM-DD). If no date is provided, the manifest for today will be returned. The manifest PDF document will list the shipments for your EKP, separated by billing numbers. Potentially, the document is large and response time will reflect this. <br />Additionally, the response contains a mapping of billing numbers to sheet numbers of the manifest and a mapping of shipment numbers to sheet numbers.<br />The call can be repeated as often as needed. Should a date be provided which is too old or lies within the future, HTTP 400 is returned.
     * @summary Retrieve daily manifest document
     * @param {string} [billingNumber] Customer billingNumber number.
     * @param {string} [date]
     * @param {GetManifestsIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.  Default is include the base64 encoded labels.
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getManifests(
      billingNumber?: string,
      date?: string,
      includeDocs?: GetManifestsIncludeDocsEnum,
      acceptLanguage?: string,
      options?: any
    ): AxiosPromise<SingleManifestResponse> {
      return localVarFp
        .getManifests(billingNumber, date, includeDocs, acceptLanguage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Shipments are normally \'\'closed out\'\' at a fixed time of the day (such as 6 pm, configured by EKP/account) for the date provided as shipDate in the create call.  <br />This call allows forcing the closeout for sets of shipments earlier. This will also override the original shipDate. Afterwards, the shipment cannot be changed and the shipment labels cannot be queried anymore (however they may remain cached for limited duration).  Calling closeout repeatedly for the same shipments will result in HTTP 400 for the second call. HTTP 400 will also be returned if the automatic closeout happened prior to the call. It is however possible to add new shipments, they will be manifested as well and be part of the day\'s manifest.  <br />Note on billing: The manifesting step has billing implications. Some products (Warenpost, Parcel International partially) are billed based on the shipment data available to DHL at the end of the day. All other products (including DHL Paket Standard) are billed based on production data. For more details, please contact your account representative.   #### Request It\'s changing the status of the shipment, so parameters are provided in the body.  * \'\'profile\'\' attribute - defines the user group profile. A user group is permitted to specific billing numbers. Shipments are only closed out if they belong to a billing number that the user group profile is entitled to use. This attribute is mandatory. Please use the standard user group profile \'\'STANDARD_GRUPPENPROFIL\'\' if no dedicated user group profile is available.  * \'\'billingNumber\'\' attribute - defines the billing number for which shipments shall be closed out. If a billing number is set, then only the shipments of that billing number are closed out. In that case no list of specific shipment numbers needs to be passed.  * \'\'shipmentNumbers\'\' attribute - lists the specific shipping numbers of the shipments that shall be closed out.  If all shipments shall be closed, the query parameter \'\'all\'\' needs to be set to \'\'true\'\'. In that case neither a billing number nor a list of shipment numbers need to be passed in the request body.   #### Response  * Closing status for each shipment
     * @summary Mark shipments as being ready for shipping
     * @param {ShipmentManifestingRequest} shipmentManifestingRequest
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {boolean} [all] Specify if all applicable shipments shall be marked as being ready for shipping.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    manifestsPost(
      shipmentManifestingRequest: ShipmentManifestingRequest,
      acceptLanguage?: string,
      all?: boolean,
      options?: any
    ): AxiosPromise<MultipleManifestResponse> {
      return localVarFp
        .manifestsPost(shipmentManifestingRequest, acceptLanguage, all, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ManifestsApi - object-oriented interface
 * @export
 * @class ManifestsApi
 * @extends {BaseAPI}
 */
export class ManifestsApi extends BaseAPI {
  /**
   * Return the manifest document for the specific date (abbreviated ISO8601 format YYYY-MM-DD). If no date is provided, the manifest for today will be returned. The manifest PDF document will list the shipments for your EKP, separated by billing numbers. Potentially, the document is large and response time will reflect this. <br />Additionally, the response contains a mapping of billing numbers to sheet numbers of the manifest and a mapping of shipment numbers to sheet numbers.<br />The call can be repeated as often as needed. Should a date be provided which is too old or lies within the future, HTTP 400 is returned.
   * @summary Retrieve daily manifest document
   * @param {string} [billingNumber] Customer billingNumber number.
   * @param {string} [date]
   * @param {GetManifestsIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.  Default is include the base64 encoded labels.
   * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManifestsApi
   */
  public getManifests(
    billingNumber?: string,
    date?: string,
    includeDocs?: GetManifestsIncludeDocsEnum,
    acceptLanguage?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ManifestsApiFp(this.configuration)
      .getManifests(billingNumber, date, includeDocs, acceptLanguage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Shipments are normally \'\'closed out\'\' at a fixed time of the day (such as 6 pm, configured by EKP/account) for the date provided as shipDate in the create call.  <br />This call allows forcing the closeout for sets of shipments earlier. This will also override the original shipDate. Afterwards, the shipment cannot be changed and the shipment labels cannot be queried anymore (however they may remain cached for limited duration).  Calling closeout repeatedly for the same shipments will result in HTTP 400 for the second call. HTTP 400 will also be returned if the automatic closeout happened prior to the call. It is however possible to add new shipments, they will be manifested as well and be part of the day\'s manifest.  <br />Note on billing: The manifesting step has billing implications. Some products (Warenpost, Parcel International partially) are billed based on the shipment data available to DHL at the end of the day. All other products (including DHL Paket Standard) are billed based on production data. For more details, please contact your account representative.   #### Request It\'s changing the status of the shipment, so parameters are provided in the body.  * \'\'profile\'\' attribute - defines the user group profile. A user group is permitted to specific billing numbers. Shipments are only closed out if they belong to a billing number that the user group profile is entitled to use. This attribute is mandatory. Please use the standard user group profile \'\'STANDARD_GRUPPENPROFIL\'\' if no dedicated user group profile is available.  * \'\'billingNumber\'\' attribute - defines the billing number for which shipments shall be closed out. If a billing number is set, then only the shipments of that billing number are closed out. In that case no list of specific shipment numbers needs to be passed.  * \'\'shipmentNumbers\'\' attribute - lists the specific shipping numbers of the shipments that shall be closed out.  If all shipments shall be closed, the query parameter \'\'all\'\' needs to be set to \'\'true\'\'. In that case neither a billing number nor a list of shipment numbers need to be passed in the request body.   #### Response  * Closing status for each shipment
   * @summary Mark shipments as being ready for shipping
   * @param {ShipmentManifestingRequest} shipmentManifestingRequest
   * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
   * @param {boolean} [all] Specify if all applicable shipments shall be marked as being ready for shipping.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManifestsApi
   */
  public manifestsPost(
    shipmentManifestingRequest: ShipmentManifestingRequest,
    acceptLanguage?: string,
    all?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return ManifestsApiFp(this.configuration)
      .manifestsPost(shipmentManifestingRequest, acceptLanguage, all, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetManifestsIncludeDocsEnum = {
  Include: 'include',
  Url: 'URL',
} as const;
export type GetManifestsIncludeDocsEnum =
  (typeof GetManifestsIncludeDocsEnum)[keyof typeof GetManifestsIncludeDocsEnum];

/**
 * ShipmentsAndLabelsApi - axios parameter creator
 * @export
 */
export const ShipmentsAndLabelsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This request is used to create one or more shipments and return corresponding shipment tracking numbers, labels, and documentation. Up to 30 shipments can be created in a single call.  #### Request  The selected products and corresponding billing numbers, as well as the desired services and package details are required to create a shipment. Each shipment can have a dedicated shipper address. The example request body contains sample values for most services.  #### Response  The request will return shipment tracking numbers and the applicable labels for each shipment. If multiple shipments have been included, an HTTP 207 response (multistatus) is returned and holds detailed status for each shipment. Other standard HTTP response codes (401, 500, 400, 200, 429) are possible, too. Labels can be either provided as part of the response (base64 encoded for PDF, text for ZPL) or via URL link for view and download. Note that the format settings per query parameters apply to the shipping label. It may also apply to other labels included, depending on the configuration of your account. Label paper for return shipments can be specified separately since a different printer may be used here. If requesting labels to be provided as URL for separate download, the URLs can be shared. #### Validation   It is recommended to validate the request first prior to shipment creation by setting the `validate` query parameter to `true`. Especially, during development and test, it is recommended to perform this validation. This functionality supports both  * JSON schema validation (against this API description). During development and test, it is recommended to do this validation. JSON schema is available for local validation  * Dry run against the DHL backend  If this succeeds, actual shipment creation will also succeed.
     * @summary Create one or more shipments and their documents. (This is the primary call of the API.)
     * @param {ShipmentOrderRequest} shipmentOrderRequest
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {boolean} [validate] If provided and set to &#x60;true&#x60;, the input document will be:   * validated against JSON schema (/orders/ endpoint) at the API layer. In case of errors, HTTP 400 and details will be returned.   * validated against the DHL backend.   In that case, no state changes are happening, no data is stored, shipments neither deleted nor created, no labels being returned. The call will return a status (200, 400) for each shipment element.
     * @param {boolean} [mustEncode] Legacy name **printOnlyIfCodable**. If set to *true*, labels will only be created if an address is encodable. This is only relevant for German consignee addresses. If set to false or left out, addresses, that are not encodable will be printed even though you receive a warning.
     * @param {CreateOrdersIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.
     * @param {CreateOrdersDocFormatEnum} [docFormat] **Defines** the **printable** document format to be used for label and manifest documents.
     * @param {CreateOrdersPrintFormatEnum} [printFormat] **Defines** the print medium for the shipping label. The different option vary from standard paper sizes DIN A4 and DIN A5 to specific label print formats.  Specific laser print formats using DIN A5 blanks are: * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank: * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats: * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {CreateOrdersRetourePrintFormatEnum} [retourePrintFormat] **Defines** the print medium for the return shipping label. This parameter is only usable, if you do not use **combined printing**. The different option vary from standard paper sizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are: * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank: * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats: * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {boolean} [combine] If set, label and return label for one shipment will be printed as single PDF document with possibly multiple pages. Else, those two labels come as separate documents. The option does not affect customs documents and COD labels.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrders: async (
      shipmentOrderRequest: ShipmentOrderRequest,
      acceptLanguage?: string,
      validate?: boolean,
      mustEncode?: boolean,
      includeDocs?: CreateOrdersIncludeDocsEnum,
      docFormat?: CreateOrdersDocFormatEnum,
      printFormat?: CreateOrdersPrintFormatEnum,
      retourePrintFormat?: CreateOrdersRetourePrintFormatEnum,
      combine?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipmentOrderRequest' is not null or undefined
      assertParamExists(
        'createOrders',
        'shipmentOrderRequest',
        shipmentOrderRequest
      );
      const localVarPath = `/orders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'dhl-api-key',
        configuration
      );

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (validate !== undefined) {
        localVarQueryParameter['validate'] = validate;
      }

      if (mustEncode !== undefined) {
        localVarQueryParameter['mustEncode'] = mustEncode;
      }

      if (includeDocs !== undefined) {
        localVarQueryParameter['includeDocs'] = includeDocs;
      }

      if (docFormat !== undefined) {
        localVarQueryParameter['docFormat'] = docFormat;
      }

      if (printFormat !== undefined) {
        localVarQueryParameter['printFormat'] = printFormat;
      }

      if (retourePrintFormat !== undefined) {
        localVarQueryParameter['retourePrintFormat'] = retourePrintFormat;
      }

      if (combine !== undefined) {
        localVarQueryParameter['combine'] = combine;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        shipmentOrderRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Public download URL for shipment labels and documents. The URL is provided in the response of the POST /orders or GET /orders resources. The document is identified via the token query parameter. There is no additional authorization, the resource URL can be shared. Please protect the URL as needed. The call returns a PDF label.
     * @summary Download PDF document
     * @param {string} token Identifies PDF document and requested print settings for download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabel: async (
      token: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'token' is not null or undefined
      assertParamExists('getLabel', 'token', token);
      const localVarPath = `/labels`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (token !== undefined) {
        localVarQueryParameter['token'] = token;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns documents for existing shipment(s). The call accepts multiple shipment numbers and will provide sets of documents for those. The **format (PDF,ZPL)** and **method of delivery (URL, encoded, data)** can be selected for **all** shipments and labels in that call. You cannot chose one format and delivery method for one label and different for another label within the same call. You can also specify if you want regular labels, return labels, cod labels, or customsDoc. Any combination is possible.  The call returns for each shipment number the status indicator and the selected labels and documents. If a label type (for example a cod label) does not exist for a shipment, it will not be returned. This is not an error. If you were sending multiple shipments, you will get an HTTP 207 response (multistatus) with detailed status for each shipment. Other standard HTTP response codes (200, 400, 401, 429, 500) are possible as well. Labels can be either provided as part of the response (base64 encoded for PDF, text for ZPL) or via URL link for view and download (PDF). Note that the format settings per query parameters apply to the shipping label. Retoure label paper type can be specified separately since a different printer may be used here. If requesting labels to be returned as URL for separate download, the URLs provided can be shared.
     * @summary Retrieve shipment documents - labels and customs documents
     * @param {Array<string>} shipment This parameter identifies shipments. The parameter can be used multiple times in one request to get the labels and/or documents for up to 30 shipments maximum. Only documents and label for shipments that are not yet closed can be retrieved.
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {GetOrderDocFormatEnum} [docFormat] **Defines** the **printable** document format to be used for label and manifest documents.
     * @param {GetOrderPrintFormatEnum} [printFormat] **Defines** the print medium for the shipping label. The different option vary from standard papersizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are:  * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank:  * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats:  * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {GetOrderRetourePrintFormatEnum} [retourePrintFormat] **Defines** the print medium for the return shipping label. This parameter is only usable, if you do not use **combined printing**. The different option vary from standard papersizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are:  * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank:  * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats:  * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {GetOrderIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.  Default is include the base64 encoded labels.
     * @param {boolean} [combine] If set, label and return label for one shipment will be printed as single PDF document with possibly multiple pages. Else, those two labels come as separate documents. The option does not affect customs documents and COD labels.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder: async (
      shipment: Array<string>,
      acceptLanguage?: string,
      docFormat?: GetOrderDocFormatEnum,
      printFormat?: GetOrderPrintFormatEnum,
      retourePrintFormat?: GetOrderRetourePrintFormatEnum,
      includeDocs?: GetOrderIncludeDocsEnum,
      combine?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipment' is not null or undefined
      assertParamExists('getOrder', 'shipment', shipment);
      const localVarPath = `/orders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'dhl-api-key',
        configuration
      );

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (shipment) {
        localVarQueryParameter['shipment'] = shipment;
      }

      if (docFormat !== undefined) {
        localVarQueryParameter['docFormat'] = docFormat;
      }

      if (printFormat !== undefined) {
        localVarQueryParameter['printFormat'] = printFormat;
      }

      if (retourePrintFormat !== undefined) {
        localVarQueryParameter['retourePrintFormat'] = retourePrintFormat;
      }

      if (includeDocs !== undefined) {
        localVarQueryParameter['includeDocs'] = includeDocs;
      }

      if (combine !== undefined) {
        localVarQueryParameter['combine'] = combine;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete one or more shipments created earlier. Deletion of shipments is only possible prior to them being manifested (closed out, \'Tagesabschluss\'). The call will return HTTP 200 (single shipment) or 207 on success, with individual status elements for each shipment. Individual status elements are HTTP 200, 400. 400 will be returned when shipment does not exist (or was already deleted).
     * @summary Delete one or more shipments
     * @param {string} profile Defines the user group profile. A user group is permitted to specific billing numbers. Shipments are only canceled if they belong to a billing number that the user group profile is entitled to use. This attribute is mandatory. Please use the standard user group profile \&#39;STANDARD_GRUPPENPROFIL\&#39; if no dedicated user group profile is available.
     * @param {string} shipment Shipment number that shall be canceled. If multiple shipments shall be canceled, the parameter must be added multiple times. Up to 30 shipments can be canceled at once.
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersAccountDelete: async (
      profile: string,
      shipment: string,
      acceptLanguage?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'profile' is not null or undefined
      assertParamExists('ordersAccountDelete', 'profile', profile);
      // verify required parameter 'shipment' is not null or undefined
      assertParamExists('ordersAccountDelete', 'shipment', shipment);
      const localVarPath = `/orders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ApiKey required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'dhl-api-key',
        configuration
      );

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (profile !== undefined) {
        localVarQueryParameter['profile'] = profile;
      }

      if (shipment !== undefined) {
        localVarQueryParameter['shipment'] = shipment;
      }

      if (acceptLanguage != null) {
        localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ShipmentsAndLabelsApi - functional programming interface
 * @export
 */
export const ShipmentsAndLabelsApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    ShipmentsAndLabelsApiAxiosParamCreator(configuration);
  return {
    /**
     * This request is used to create one or more shipments and return corresponding shipment tracking numbers, labels, and documentation. Up to 30 shipments can be created in a single call.  #### Request  The selected products and corresponding billing numbers, as well as the desired services and package details are required to create a shipment. Each shipment can have a dedicated shipper address. The example request body contains sample values for most services.  #### Response  The request will return shipment tracking numbers and the applicable labels for each shipment. If multiple shipments have been included, an HTTP 207 response (multistatus) is returned and holds detailed status for each shipment. Other standard HTTP response codes (401, 500, 400, 200, 429) are possible, too. Labels can be either provided as part of the response (base64 encoded for PDF, text for ZPL) or via URL link for view and download. Note that the format settings per query parameters apply to the shipping label. It may also apply to other labels included, depending on the configuration of your account. Label paper for return shipments can be specified separately since a different printer may be used here. If requesting labels to be provided as URL for separate download, the URLs can be shared. #### Validation   It is recommended to validate the request first prior to shipment creation by setting the `validate` query parameter to `true`. Especially, during development and test, it is recommended to perform this validation. This functionality supports both  * JSON schema validation (against this API description). During development and test, it is recommended to do this validation. JSON schema is available for local validation  * Dry run against the DHL backend  If this succeeds, actual shipment creation will also succeed.
     * @summary Create one or more shipments and their documents. (This is the primary call of the API.)
     * @param {ShipmentOrderRequest} shipmentOrderRequest
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {boolean} [validate] If provided and set to &#x60;true&#x60;, the input document will be:   * validated against JSON schema (/orders/ endpoint) at the API layer. In case of errors, HTTP 400 and details will be returned.   * validated against the DHL backend.   In that case, no state changes are happening, no data is stored, shipments neither deleted nor created, no labels being returned. The call will return a status (200, 400) for each shipment element.
     * @param {boolean} [mustEncode] Legacy name **printOnlyIfCodable**. If set to *true*, labels will only be created if an address is encodable. This is only relevant for German consignee addresses. If set to false or left out, addresses, that are not encodable will be printed even though you receive a warning.
     * @param {CreateOrdersIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.
     * @param {CreateOrdersDocFormatEnum} [docFormat] **Defines** the **printable** document format to be used for label and manifest documents.
     * @param {CreateOrdersPrintFormatEnum} [printFormat] **Defines** the print medium for the shipping label. The different option vary from standard paper sizes DIN A4 and DIN A5 to specific label print formats.  Specific laser print formats using DIN A5 blanks are: * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank: * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats: * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {CreateOrdersRetourePrintFormatEnum} [retourePrintFormat] **Defines** the print medium for the return shipping label. This parameter is only usable, if you do not use **combined printing**. The different option vary from standard paper sizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are: * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank: * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats: * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {boolean} [combine] If set, label and return label for one shipment will be printed as single PDF document with possibly multiple pages. Else, those two labels come as separate documents. The option does not affect customs documents and COD labels.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrders(
      shipmentOrderRequest: ShipmentOrderRequest,
      acceptLanguage?: string,
      validate?: boolean,
      mustEncode?: boolean,
      includeDocs?: CreateOrdersIncludeDocsEnum,
      docFormat?: CreateOrdersDocFormatEnum,
      printFormat?: CreateOrdersPrintFormatEnum,
      retourePrintFormat?: CreateOrdersRetourePrintFormatEnum,
      combine?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LabelDataResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrders(
        shipmentOrderRequest,
        acceptLanguage,
        validate,
        mustEncode,
        includeDocs,
        docFormat,
        printFormat,
        retourePrintFormat,
        combine,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ShipmentsAndLabelsApi.createOrders']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Public download URL for shipment labels and documents. The URL is provided in the response of the POST /orders or GET /orders resources. The document is identified via the token query parameter. There is no additional authorization, the resource URL can be shared. Please protect the URL as needed. The call returns a PDF label.
     * @summary Download PDF document
     * @param {string} token Identifies PDF document and requested print settings for download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLabel(
      token: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LabelDataResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLabel(
        token,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ShipmentsAndLabelsApi.getLabel']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Returns documents for existing shipment(s). The call accepts multiple shipment numbers and will provide sets of documents for those. The **format (PDF,ZPL)** and **method of delivery (URL, encoded, data)** can be selected for **all** shipments and labels in that call. You cannot chose one format and delivery method for one label and different for another label within the same call. You can also specify if you want regular labels, return labels, cod labels, or customsDoc. Any combination is possible.  The call returns for each shipment number the status indicator and the selected labels and documents. If a label type (for example a cod label) does not exist for a shipment, it will not be returned. This is not an error. If you were sending multiple shipments, you will get an HTTP 207 response (multistatus) with detailed status for each shipment. Other standard HTTP response codes (200, 400, 401, 429, 500) are possible as well. Labels can be either provided as part of the response (base64 encoded for PDF, text for ZPL) or via URL link for view and download (PDF). Note that the format settings per query parameters apply to the shipping label. Retoure label paper type can be specified separately since a different printer may be used here. If requesting labels to be returned as URL for separate download, the URLs provided can be shared.
     * @summary Retrieve shipment documents - labels and customs documents
     * @param {Array<string>} shipment This parameter identifies shipments. The parameter can be used multiple times in one request to get the labels and/or documents for up to 30 shipments maximum. Only documents and label for shipments that are not yet closed can be retrieved.
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {GetOrderDocFormatEnum} [docFormat] **Defines** the **printable** document format to be used for label and manifest documents.
     * @param {GetOrderPrintFormatEnum} [printFormat] **Defines** the print medium for the shipping label. The different option vary from standard papersizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are:  * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank:  * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats:  * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {GetOrderRetourePrintFormatEnum} [retourePrintFormat] **Defines** the print medium for the return shipping label. This parameter is only usable, if you do not use **combined printing**. The different option vary from standard papersizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are:  * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank:  * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats:  * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {GetOrderIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.  Default is include the base64 encoded labels.
     * @param {boolean} [combine] If set, label and return label for one shipment will be printed as single PDF document with possibly multiple pages. Else, those two labels come as separate documents. The option does not affect customs documents and COD labels.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrder(
      shipment: Array<string>,
      acceptLanguage?: string,
      docFormat?: GetOrderDocFormatEnum,
      printFormat?: GetOrderPrintFormatEnum,
      retourePrintFormat?: GetOrderRetourePrintFormatEnum,
      includeDocs?: GetOrderIncludeDocsEnum,
      combine?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LabelDataResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(
        shipment,
        acceptLanguage,
        docFormat,
        printFormat,
        retourePrintFormat,
        includeDocs,
        combine,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ShipmentsAndLabelsApi.getOrder']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Delete one or more shipments created earlier. Deletion of shipments is only possible prior to them being manifested (closed out, \'Tagesabschluss\'). The call will return HTTP 200 (single shipment) or 207 on success, with individual status elements for each shipment. Individual status elements are HTTP 200, 400. 400 will be returned when shipment does not exist (or was already deleted).
     * @summary Delete one or more shipments
     * @param {string} profile Defines the user group profile. A user group is permitted to specific billing numbers. Shipments are only canceled if they belong to a billing number that the user group profile is entitled to use. This attribute is mandatory. Please use the standard user group profile \&#39;STANDARD_GRUPPENPROFIL\&#39; if no dedicated user group profile is available.
     * @param {string} shipment Shipment number that shall be canceled. If multiple shipments shall be canceled, the parameter must be added multiple times. Up to 30 shipments can be canceled at once.
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ordersAccountDelete(
      profile: string,
      shipment: string,
      acceptLanguage?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LabelDataResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ordersAccountDelete(
          profile,
          shipment,
          acceptLanguage,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ShipmentsAndLabelsApi.ordersAccountDelete']?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ShipmentsAndLabelsApi - factory interface
 * @export
 */
export const ShipmentsAndLabelsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ShipmentsAndLabelsApiFp(configuration);
  return {
    /**
     * This request is used to create one or more shipments and return corresponding shipment tracking numbers, labels, and documentation. Up to 30 shipments can be created in a single call.  #### Request  The selected products and corresponding billing numbers, as well as the desired services and package details are required to create a shipment. Each shipment can have a dedicated shipper address. The example request body contains sample values for most services.  #### Response  The request will return shipment tracking numbers and the applicable labels for each shipment. If multiple shipments have been included, an HTTP 207 response (multistatus) is returned and holds detailed status for each shipment. Other standard HTTP response codes (401, 500, 400, 200, 429) are possible, too. Labels can be either provided as part of the response (base64 encoded for PDF, text for ZPL) or via URL link for view and download. Note that the format settings per query parameters apply to the shipping label. It may also apply to other labels included, depending on the configuration of your account. Label paper for return shipments can be specified separately since a different printer may be used here. If requesting labels to be provided as URL for separate download, the URLs can be shared. #### Validation   It is recommended to validate the request first prior to shipment creation by setting the `validate` query parameter to `true`. Especially, during development and test, it is recommended to perform this validation. This functionality supports both  * JSON schema validation (against this API description). During development and test, it is recommended to do this validation. JSON schema is available for local validation  * Dry run against the DHL backend  If this succeeds, actual shipment creation will also succeed.
     * @summary Create one or more shipments and their documents. (This is the primary call of the API.)
     * @param {ShipmentOrderRequest} shipmentOrderRequest
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {boolean} [validate] If provided and set to &#x60;true&#x60;, the input document will be:   * validated against JSON schema (/orders/ endpoint) at the API layer. In case of errors, HTTP 400 and details will be returned.   * validated against the DHL backend.   In that case, no state changes are happening, no data is stored, shipments neither deleted nor created, no labels being returned. The call will return a status (200, 400) for each shipment element.
     * @param {boolean} [mustEncode] Legacy name **printOnlyIfCodable**. If set to *true*, labels will only be created if an address is encodable. This is only relevant for German consignee addresses. If set to false or left out, addresses, that are not encodable will be printed even though you receive a warning.
     * @param {CreateOrdersIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.
     * @param {CreateOrdersDocFormatEnum} [docFormat] **Defines** the **printable** document format to be used for label and manifest documents.
     * @param {CreateOrdersPrintFormatEnum} [printFormat] **Defines** the print medium for the shipping label. The different option vary from standard paper sizes DIN A4 and DIN A5 to specific label print formats.  Specific laser print formats using DIN A5 blanks are: * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank: * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats: * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {CreateOrdersRetourePrintFormatEnum} [retourePrintFormat] **Defines** the print medium for the return shipping label. This parameter is only usable, if you do not use **combined printing**. The different option vary from standard paper sizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are: * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank: * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats: * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {boolean} [combine] If set, label and return label for one shipment will be printed as single PDF document with possibly multiple pages. Else, those two labels come as separate documents. The option does not affect customs documents and COD labels.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrders(
      shipmentOrderRequest: ShipmentOrderRequest,
      acceptLanguage?: string,
      validate?: boolean,
      mustEncode?: boolean,
      includeDocs?: CreateOrdersIncludeDocsEnum,
      docFormat?: CreateOrdersDocFormatEnum,
      printFormat?: CreateOrdersPrintFormatEnum,
      retourePrintFormat?: CreateOrdersRetourePrintFormatEnum,
      combine?: boolean,
      options?: any
    ): AxiosPromise<LabelDataResponse> {
      return localVarFp
        .createOrders(
          shipmentOrderRequest,
          acceptLanguage,
          validate,
          mustEncode,
          includeDocs,
          docFormat,
          printFormat,
          retourePrintFormat,
          combine,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Public download URL for shipment labels and documents. The URL is provided in the response of the POST /orders or GET /orders resources. The document is identified via the token query parameter. There is no additional authorization, the resource URL can be shared. Please protect the URL as needed. The call returns a PDF label.
     * @summary Download PDF document
     * @param {string} token Identifies PDF document and requested print settings for download.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabel(token: string, options?: any): AxiosPromise<LabelDataResponse> {
      return localVarFp
        .getLabel(token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns documents for existing shipment(s). The call accepts multiple shipment numbers and will provide sets of documents for those. The **format (PDF,ZPL)** and **method of delivery (URL, encoded, data)** can be selected for **all** shipments and labels in that call. You cannot chose one format and delivery method for one label and different for another label within the same call. You can also specify if you want regular labels, return labels, cod labels, or customsDoc. Any combination is possible.  The call returns for each shipment number the status indicator and the selected labels and documents. If a label type (for example a cod label) does not exist for a shipment, it will not be returned. This is not an error. If you were sending multiple shipments, you will get an HTTP 207 response (multistatus) with detailed status for each shipment. Other standard HTTP response codes (200, 400, 401, 429, 500) are possible as well. Labels can be either provided as part of the response (base64 encoded for PDF, text for ZPL) or via URL link for view and download (PDF). Note that the format settings per query parameters apply to the shipping label. Retoure label paper type can be specified separately since a different printer may be used here. If requesting labels to be returned as URL for separate download, the URLs provided can be shared.
     * @summary Retrieve shipment documents - labels and customs documents
     * @param {Array<string>} shipment This parameter identifies shipments. The parameter can be used multiple times in one request to get the labels and/or documents for up to 30 shipments maximum. Only documents and label for shipments that are not yet closed can be retrieved.
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {GetOrderDocFormatEnum} [docFormat] **Defines** the **printable** document format to be used for label and manifest documents.
     * @param {GetOrderPrintFormatEnum} [printFormat] **Defines** the print medium for the shipping label. The different option vary from standard papersizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are:  * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank:  * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats:  * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {GetOrderRetourePrintFormatEnum} [retourePrintFormat] **Defines** the print medium for the return shipping label. This parameter is only usable, if you do not use **combined printing**. The different option vary from standard papersizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are:  * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank:  * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats:  * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
     * @param {GetOrderIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.  Default is include the base64 encoded labels.
     * @param {boolean} [combine] If set, label and return label for one shipment will be printed as single PDF document with possibly multiple pages. Else, those two labels come as separate documents. The option does not affect customs documents and COD labels.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder(
      shipment: Array<string>,
      acceptLanguage?: string,
      docFormat?: GetOrderDocFormatEnum,
      printFormat?: GetOrderPrintFormatEnum,
      retourePrintFormat?: GetOrderRetourePrintFormatEnum,
      includeDocs?: GetOrderIncludeDocsEnum,
      combine?: boolean,
      options?: any
    ): AxiosPromise<LabelDataResponse> {
      return localVarFp
        .getOrder(
          shipment,
          acceptLanguage,
          docFormat,
          printFormat,
          retourePrintFormat,
          includeDocs,
          combine,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete one or more shipments created earlier. Deletion of shipments is only possible prior to them being manifested (closed out, \'Tagesabschluss\'). The call will return HTTP 200 (single shipment) or 207 on success, with individual status elements for each shipment. Individual status elements are HTTP 200, 400. 400 will be returned when shipment does not exist (or was already deleted).
     * @summary Delete one or more shipments
     * @param {string} profile Defines the user group profile. A user group is permitted to specific billing numbers. Shipments are only canceled if they belong to a billing number that the user group profile is entitled to use. This attribute is mandatory. Please use the standard user group profile \&#39;STANDARD_GRUPPENPROFIL\&#39; if no dedicated user group profile is available.
     * @param {string} shipment Shipment number that shall be canceled. If multiple shipments shall be canceled, the parameter must be added multiple times. Up to 30 shipments can be canceled at once.
     * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ordersAccountDelete(
      profile: string,
      shipment: string,
      acceptLanguage?: string,
      options?: any
    ): AxiosPromise<LabelDataResponse> {
      return localVarFp
        .ordersAccountDelete(profile, shipment, acceptLanguage, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ShipmentsAndLabelsApi - object-oriented interface
 * @export
 * @class ShipmentsAndLabelsApi
 * @extends {BaseAPI}
 */
export class ShipmentsAndLabelsApi extends BaseAPI {
  /**
   * This request is used to create one or more shipments and return corresponding shipment tracking numbers, labels, and documentation. Up to 30 shipments can be created in a single call.  #### Request  The selected products and corresponding billing numbers, as well as the desired services and package details are required to create a shipment. Each shipment can have a dedicated shipper address. The example request body contains sample values for most services.  #### Response  The request will return shipment tracking numbers and the applicable labels for each shipment. If multiple shipments have been included, an HTTP 207 response (multistatus) is returned and holds detailed status for each shipment. Other standard HTTP response codes (401, 500, 400, 200, 429) are possible, too. Labels can be either provided as part of the response (base64 encoded for PDF, text for ZPL) or via URL link for view and download. Note that the format settings per query parameters apply to the shipping label. It may also apply to other labels included, depending on the configuration of your account. Label paper for return shipments can be specified separately since a different printer may be used here. If requesting labels to be provided as URL for separate download, the URLs can be shared. #### Validation   It is recommended to validate the request first prior to shipment creation by setting the `validate` query parameter to `true`. Especially, during development and test, it is recommended to perform this validation. This functionality supports both  * JSON schema validation (against this API description). During development and test, it is recommended to do this validation. JSON schema is available for local validation  * Dry run against the DHL backend  If this succeeds, actual shipment creation will also succeed.
   * @summary Create one or more shipments and their documents. (This is the primary call of the API.)
   * @param {ShipmentOrderRequest} shipmentOrderRequest
   * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
   * @param {boolean} [validate] If provided and set to &#x60;true&#x60;, the input document will be:   * validated against JSON schema (/orders/ endpoint) at the API layer. In case of errors, HTTP 400 and details will be returned.   * validated against the DHL backend.   In that case, no state changes are happening, no data is stored, shipments neither deleted nor created, no labels being returned. The call will return a status (200, 400) for each shipment element.
   * @param {boolean} [mustEncode] Legacy name **printOnlyIfCodable**. If set to *true*, labels will only be created if an address is encodable. This is only relevant for German consignee addresses. If set to false or left out, addresses, that are not encodable will be printed even though you receive a warning.
   * @param {CreateOrdersIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.
   * @param {CreateOrdersDocFormatEnum} [docFormat] **Defines** the **printable** document format to be used for label and manifest documents.
   * @param {CreateOrdersPrintFormatEnum} [printFormat] **Defines** the print medium for the shipping label. The different option vary from standard paper sizes DIN A4 and DIN A5 to specific label print formats.  Specific laser print formats using DIN A5 blanks are: * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank: * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats: * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
   * @param {CreateOrdersRetourePrintFormatEnum} [retourePrintFormat] **Defines** the print medium for the return shipping label. This parameter is only usable, if you do not use **combined printing**. The different option vary from standard paper sizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are: * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank: * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats: * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
   * @param {boolean} [combine] If set, label and return label for one shipment will be printed as single PDF document with possibly multiple pages. Else, those two labels come as separate documents. The option does not affect customs documents and COD labels.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ShipmentsAndLabelsApi
   */
  public createOrders(
    shipmentOrderRequest: ShipmentOrderRequest,
    acceptLanguage?: string,
    validate?: boolean,
    mustEncode?: boolean,
    includeDocs?: CreateOrdersIncludeDocsEnum,
    docFormat?: CreateOrdersDocFormatEnum,
    printFormat?: CreateOrdersPrintFormatEnum,
    retourePrintFormat?: CreateOrdersRetourePrintFormatEnum,
    combine?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return ShipmentsAndLabelsApiFp(this.configuration)
      .createOrders(
        shipmentOrderRequest,
        acceptLanguage,
        validate,
        mustEncode,
        includeDocs,
        docFormat,
        printFormat,
        retourePrintFormat,
        combine,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Public download URL for shipment labels and documents. The URL is provided in the response of the POST /orders or GET /orders resources. The document is identified via the token query parameter. There is no additional authorization, the resource URL can be shared. Please protect the URL as needed. The call returns a PDF label.
   * @summary Download PDF document
   * @param {string} token Identifies PDF document and requested print settings for download.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ShipmentsAndLabelsApi
   */
  public getLabel(token: string, options?: RawAxiosRequestConfig) {
    return ShipmentsAndLabelsApiFp(this.configuration)
      .getLabel(token, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns documents for existing shipment(s). The call accepts multiple shipment numbers and will provide sets of documents for those. The **format (PDF,ZPL)** and **method of delivery (URL, encoded, data)** can be selected for **all** shipments and labels in that call. You cannot chose one format and delivery method for one label and different for another label within the same call. You can also specify if you want regular labels, return labels, cod labels, or customsDoc. Any combination is possible.  The call returns for each shipment number the status indicator and the selected labels and documents. If a label type (for example a cod label) does not exist for a shipment, it will not be returned. This is not an error. If you were sending multiple shipments, you will get an HTTP 207 response (multistatus) with detailed status for each shipment. Other standard HTTP response codes (200, 400, 401, 429, 500) are possible as well. Labels can be either provided as part of the response (base64 encoded for PDF, text for ZPL) or via URL link for view and download (PDF). Note that the format settings per query parameters apply to the shipping label. Retoure label paper type can be specified separately since a different printer may be used here. If requesting labels to be returned as URL for separate download, the URLs provided can be shared.
   * @summary Retrieve shipment documents - labels and customs documents
   * @param {Array<string>} shipment This parameter identifies shipments. The parameter can be used multiple times in one request to get the labels and/or documents for up to 30 shipments maximum. Only documents and label for shipments that are not yet closed can be retrieved.
   * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
   * @param {GetOrderDocFormatEnum} [docFormat] **Defines** the **printable** document format to be used for label and manifest documents.
   * @param {GetOrderPrintFormatEnum} [printFormat] **Defines** the print medium for the shipping label. The different option vary from standard papersizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are:  * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank:  * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats:  * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
   * @param {GetOrderRetourePrintFormatEnum} [retourePrintFormat] **Defines** the print medium for the return shipping label. This parameter is only usable, if you do not use **combined printing**. The different option vary from standard papersizes DIN A4 and DIN A5 to specific label print formats.   Specific laser print formats using DIN A5 blanks are:  * 910-300-600(-oz) (105 x 205mm) * 910-300-300(-oz) (105 x 148mm)  Specific laser print formats **not** using a DIN A5 blank:  * 910-300-610 (105 x 208mm) * 100x70mm  Specific thermal print formats:  * 910-300-600 (103 x 199mm) * 910-300-400 (103 x 150mm) * 100x70mm  Please use the different formats as follows. If you do not set the parameter the settings of DHL costumer portal account will be used as default.
   * @param {GetOrderIncludeDocsEnum} [includeDocs] Legacy name **labelResponseType**. Shipping labels and further shipment documents can be:  * __include__: included as base64 encoded data in the response (default)  * __URL__: provided as URL reference.  Default is include the base64 encoded labels.
   * @param {boolean} [combine] If set, label and return label for one shipment will be printed as single PDF document with possibly multiple pages. Else, those two labels come as separate documents. The option does not affect customs documents and COD labels.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ShipmentsAndLabelsApi
   */
  public getOrder(
    shipment: Array<string>,
    acceptLanguage?: string,
    docFormat?: GetOrderDocFormatEnum,
    printFormat?: GetOrderPrintFormatEnum,
    retourePrintFormat?: GetOrderRetourePrintFormatEnum,
    includeDocs?: GetOrderIncludeDocsEnum,
    combine?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return ShipmentsAndLabelsApiFp(this.configuration)
      .getOrder(
        shipment,
        acceptLanguage,
        docFormat,
        printFormat,
        retourePrintFormat,
        includeDocs,
        combine,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete one or more shipments created earlier. Deletion of shipments is only possible prior to them being manifested (closed out, \'Tagesabschluss\'). The call will return HTTP 200 (single shipment) or 207 on success, with individual status elements for each shipment. Individual status elements are HTTP 200, 400. 400 will be returned when shipment does not exist (or was already deleted).
   * @summary Delete one or more shipments
   * @param {string} profile Defines the user group profile. A user group is permitted to specific billing numbers. Shipments are only canceled if they belong to a billing number that the user group profile is entitled to use. This attribute is mandatory. Please use the standard user group profile \&#39;STANDARD_GRUPPENPROFIL\&#39; if no dedicated user group profile is available.
   * @param {string} shipment Shipment number that shall be canceled. If multiple shipments shall be canceled, the parameter must be added multiple times. Up to 30 shipments can be canceled at once.
   * @param {string} [acceptLanguage] Control the APIs response language via locale abbreviation. English (en-US) and german (de-DE) are supported. If not specified, the default is english.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ShipmentsAndLabelsApi
   */
  public ordersAccountDelete(
    profile: string,
    shipment: string,
    acceptLanguage?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ShipmentsAndLabelsApiFp(this.configuration)
      .ordersAccountDelete(profile, shipment, acceptLanguage, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const CreateOrdersIncludeDocsEnum = {
  Include: 'include',
  Url: 'URL',
} as const;
export type CreateOrdersIncludeDocsEnum =
  (typeof CreateOrdersIncludeDocsEnum)[keyof typeof CreateOrdersIncludeDocsEnum];
/**
 * @export
 */
export const CreateOrdersDocFormatEnum = {
  Zpl2: 'ZPL2',
  Pdf: 'PDF',
} as const;
export type CreateOrdersDocFormatEnum =
  (typeof CreateOrdersDocFormatEnum)[keyof typeof CreateOrdersDocFormatEnum];
/**
 * @export
 */
export const CreateOrdersPrintFormatEnum = {
  A4: 'A4',
  _910300600: '910-300-600',
  _910300610: '910-300-610',
  _910300700: '910-300-700',
  _910300700Oz: '910-300-700-oz',
  _910300710: '910-300-710',
  _910300300: '910-300-300',
  _910300300Oz: '910-300-300-oz',
  _910300400: '910-300-400',
  _910300410: '910-300-410',
  _100x70mm: '100x70mm',
} as const;
export type CreateOrdersPrintFormatEnum =
  (typeof CreateOrdersPrintFormatEnum)[keyof typeof CreateOrdersPrintFormatEnum];
/**
 * @export
 */
export const CreateOrdersRetourePrintFormatEnum = {
  A4: 'A4',
  _910300600: '910-300-600',
  _910300610: '910-300-610',
  _910300700: '910-300-700',
  _910300700Oz: '910-300-700-oz',
  _910300710: '910-300-710',
  _910300300: '910-300-300',
  _910300300Oz: '910-300-300-oz',
  _910300400: '910-300-400',
  _910300410: '910-300-410',
  _100x70mm: '100x70mm',
} as const;
export type CreateOrdersRetourePrintFormatEnum =
  (typeof CreateOrdersRetourePrintFormatEnum)[keyof typeof CreateOrdersRetourePrintFormatEnum];
/**
 * @export
 */
export const GetOrderDocFormatEnum = {
  Zpl2: 'ZPL2',
  Pdf: 'PDF',
} as const;
export type GetOrderDocFormatEnum =
  (typeof GetOrderDocFormatEnum)[keyof typeof GetOrderDocFormatEnum];
/**
 * @export
 */
export const GetOrderPrintFormatEnum = {
  A4: 'A4',
  _910300600: '910-300-600',
  _910300610: '910-300-610',
  _910300700: '910-300-700',
  _910300700Oz: '910-300-700-oz',
  _910300710: '910-300-710',
  _910300300: '910-300-300',
  _910300300Oz: '910-300-300-oz',
  _910300400: '910-300-400',
  _910300410: '910-300-410',
  _100x70mm: '100x70mm',
} as const;
export type GetOrderPrintFormatEnum =
  (typeof GetOrderPrintFormatEnum)[keyof typeof GetOrderPrintFormatEnum];
/**
 * @export
 */
export const GetOrderRetourePrintFormatEnum = {
  A4: 'A4',
  _910300600: '910-300-600',
  _910300610: '910-300-610',
  _910300700: '910-300-700',
  _910300700Oz: '910-300-700-oz',
  _910300710: '910-300-710',
  _910300300: '910-300-300',
  _910300300Oz: '910-300-300-oz',
  _910300400: '910-300-400',
  _910300410: '910-300-410',
  _100x70mm: '100x70mm',
} as const;
export type GetOrderRetourePrintFormatEnum =
  (typeof GetOrderRetourePrintFormatEnum)[keyof typeof GetOrderRetourePrintFormatEnum];
/**
 * @export
 */
export const GetOrderIncludeDocsEnum = {
  Include: 'include',
  Url: 'URL',
} as const;
export type GetOrderIncludeDocsEnum =
  (typeof GetOrderIncludeDocsEnum)[keyof typeof GetOrderIncludeDocsEnum];
